\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algpseudocode}
\title{Hardware RSA Accelerator}
\author{Group 3: Ariel Anders, Timur Balbekov, Neil Forrester}


\begin{document}

\maketitle
\tableofcontents

\begin{abstract}
%Project Objective Describe the goal of the project. What problem are you trying to solve? How is the FPGA involved in the solution of that problem? Include relevant specific details such as the target frame rate, bit rate, frame dimensions, or message sizes.
Our project is implementing the RSA cryptographic algorithm in Bluespec.
The benefits of doing this in hardware are higher performance, reduced power usage and size, and cost.
Having reusable IP that implements RSA would allow a device manufacturer to either reduce their
power footprint, or skip inclusion of a processor in a device that otherwise would not need one.  

More specifically, our objective is to implement the encryption and decryption protocols in RSA for 1024 bit messages on the XUPV5 Bluespec ...speed.  (include some speed stuff here)
\end{abstract}
%%%
\chapter{Background}
CITE WIKIPEDIA!!
Assume the readers of your final report are not intimately familiar with your project
domain. Provide enough high level background about the domain or algorithms involved for
the reader to get an idea of the scope of the project and understand significant design choices
described later in the document.
Include the benefits of using an FPGA for this application.

RSA is an encryption protocol that involves a public and private key.  As indignant of its name, the public key is known to everyone and is used to encrypt messages, which are called "ciphertext".  The ciphertext can then be decrypted using the private key.  Our implementation assumes the public and private keys are generated prior to encryption through with the FPGA.    
\section{RSA Algorithm}
\subsection{Definition of Variables for the RSA Algorithm}
\begin{description}
\item[Public Key ($n$, $e$)] A public key consists of the modulus $n$ and encryption exponent $e$
\item[Private Key ($n$, $d$)]A  private key consists of the same modulus $n$ and the private decryption exponent $d$
\item[Message ($m$)] The plain text message converted into an integer $m$, such that $0 \leq m \leq n$ 
\item[Ciphertext ($c$)]  The plain text message encrypted using the public key
\end{description}
\subsection{Encryption}
The ciphertext is generated by encrypting the plain text message using the public key:
\begin{equation}
  c \equiv m^e\ (mod\ n)
\end{equation}
\subsection{Decryption}
The plaintext message is generated by decrypting the ciphertext message using the private key:
\begin{equation}
  m \equiv c^d\ (mod\ n)
\end{equation}
%%%
\section{RSA Algorithm for Hardware Implementation}
Using a naive approach to implement this algorithm would clearly run quickly out of space.  Instead, we have selected two algorithms that blablabla good space yada yada yada
Copied algorithms over... still needs to be cleaned up
\subsection{Modular Exponentiation}
This module will employ the Right-to-left binary algorithm, which we believe is a good compromise between speed, memory usage, and complexity.
The goal of the algorithm is to calculate $b^e \bmod m$ for very large values of $b$, $e$, and $m$.
If the bits of $e$ are $e_1, e_2 \dots e_n$:
\begin{equation}
e = \sum_{i = 0}^{n} e_i 2^i
\end{equation}
then:
\begin{equation}
b^e = \prod_{i = 0}^{n} e_i b^{(2^i)}
\end{equation}
and since:
\begin{equation}
a * b \bmod m = (a \bmod m) * (b \bmod m) \bmod m
\end{equation}
then every intermediate result can be taken modulo $m$ to keep the size of intermediate results manageable.
Therefore, the following algorithm will compute $b^e \bmod m$ in a reasonable amount of time and memory:
\begin{algorithmic}
\State $b$, $e$, and $m$ are the inputs to the algorithm.
\State $c \gets 1$
\While{$e > 0$}
	\If{$e \bmod 2 = 1$}
		\State $c \gets c * b \bmod m$
	\EndIf
	\State $b \gets b * b \bmod m$
	\State $e \gets \lfloor e / 2 \rfloor$
\EndWhile
\State $c$ is the result of the algorithm.
\end{algorithmic}
This very naturally suggests a circular pipeline in hardware.
If parallelism is desired, then multiple circular pipelines may be put in parallel,
with some logic at the front and back to manage handing out jobs to different circular pipelines,
and collecting the results.
The only remaining problem is performing multiplication, modulo, and bit shifting which is implemented through the interleaved modular multiplication algorithm which requires bit shifts, additions, subtractions, and bitwise comparisons and does not take up excessive area. 
\subsection{Interleaved Modulus Multiplication}
$N$ is the size of the numbers, in bits. For example, $N = 1024$.
Also, $x_i$ is the $i$th bit of $x$.
\begin{algorithmic}
\State $x$, $y$, and $m$ are the inputs to the algorithm.
\State $p \gets 0$
\State $i \gets N - 1$
\While{$i \geq 0$}
	\State $p \gets p * 2$
	\If{$x_i = 1$}
		\State $p \gets p + y$
	\EndIf
	\If{$p \geq m$}
		\State $p \gets p - m$
	\EndIf
	\If{$p \geq m$}
		\State $p \gets p - m$
	\EndIf
  \State $i \gets i - 1$
\EndWhile
\State $p$ is the result of the algorithm.
\end{algorithmic}
\chapter*{High-Level Design and Test Plan} Describe your system at a high level. What components are
running in software, what in hardware, and how do they interact? What are the inputs and
outputs to the system? How is the system used? How do you test the system? Include system
diagrams.
%%%
\chapter*{Microarchitectural Description} Describe the microarchitecture of your project. What are the
component modules of your design and how do they interact? What significant design decisions
led you to your microarchitecture?
%%%
\chapter*{Implementation Evaluation}
 What challenges or surprises did you face in implementing your
design? Did you end up making changes to your original microarchitecture? Did you encounter
any problems moving the design from simulation to the FPGA?
Describe the results of your implementation. How many lines of Bluespec code did you have to
write or modify? What existing IP blocks were you able to make use of in your design (DDR,
dividers, etc...). What was the device utilization of your design, the clock frequency, and the
high level throughput (frames per second, bits decoded per second, etc...). Did you meet your
initial project goals? Why or why not?
%%%
\chapter*{Design Exploration}
 Now that you have a working system, what trade-offs would you be interested
in exploring?
If you didnâ€™t meet your performance targets, why? What are the limiting components in
your design? A detailed analysis of the cycle latency and throughput of each component in
your design may be appropriate. 

\chapter*{Conclusion}

\end{document}
